# -*- coding: utf-8 -*-
"""
Created on Thu Apr  4 11:10:32 2019

@author: rounak
"""

import numpy as np
import scipy.sparse as sp

#%% Global Variables
global base_mva, base_kV, omega, Zbase
base_mva = 100.0
base_kV = 138.0
omega = 2*np.pi*60
Zbase = (base_kV**2)/base_mva


#%% Functions
def KronRed(A,col1,col2):
    '''
    '''
    K1 = A[col1,col1.T]
    K2 = A[col1,col2.T]
    K3 = A[col2,col1.T]
    K4 = A[col2,col2.T]
    return K1 - np.matmul(np.matmul(K2,np.linalg.inv(K4)),K3)


def full_Ybus(bus,line,tx):
    '''
    Evaluates the Ybus matrix for a given power system network.
    #######################################################################
    REQUIRES UPDATE USING EFFICIENT CSR MATRIX ALGORITHM
    CURRENTLY JUST CONVERTS NUMPY 2D ARRAY TO A CSR MATRIX.
    NEED TO FILL THE ENTIRE MATRIX AS A CSR MATRIX (COMPUTATIONALLY AND
    MEMORYWISE EFFICIENT)
    #######################################################################
    '''
    
    Ybus = np.zeros(shape=(len(bus),len(bus)),dtype=complex)
    # Shunt admittances of each bus
    for m in range(len(bus)):
        g = bus[m]['g']/base_mva
        b = bus[m]['b']/base_mva
        Ybus[m,m] += complex(g,b)
    # Line impedances and admittances
    for k in range(len(line)):
        # find index of buses
        ind_fbus = bus.ind(line[k]['frombus'])
        ind_tbus = bus.ind(line[k]['tobus'])
        # evaluate resistance, reactance and susceptance
        if line[k]['length']==0.0:
            length = 1.0
        else:
            length = line[k]['length']
        r = line[k]['r']*length*base_mva/line[k]['mva']
        x = line[k]['x']*length*base_mva/line[k]['mva']
        b = line[k]['b']*length*line[k]['mva']/base_mva
        # add off-diagonal elements of Ybus
        Ybus[ind_fbus,ind_tbus] += -1/complex(r,x)
        Ybus[ind_tbus,ind_fbus] += -1/complex(r,x)
        # add diagonal elements of Ybus
        Ybus[ind_fbus,ind_fbus] += 1/complex(r,x)
        Ybus[ind_tbus,ind_tbus] += 1/complex(r,x)
        Ybus[ind_fbus,ind_fbus] += complex(0,b/2)
        Ybus[ind_tbus,ind_tbus] += complex(0,b/2)
    # Transformer impedances and admittances
    #######################################################################
    #Requires checking of pu calculation for transfomrer voltage
    #How to calculate pu impedance for transformer for any base 
    #######################################################################
    for t in range(len(tx)):
        # find index of buses
        ind_fbus = bus.ind(tx[t]['frombus'])
        ind_tbus = bus.ind(tx[t]['tobus'])
        # evaluate resistance, reactance and susceptance
        r = tx[t]['r']*base_mva/tx[t]['mva']
        x = tx[t]['x']*base_mva/tx[t]['mva']
        g = tx[t]['g']*tx[t]['mva']/base_mva
        b = tx[t]['b']*tx[t]['mva']/base_mva
        # add off-diagonal elements of Ybus
        Ybus[ind_fbus,ind_tbus] += -1/complex(r,x)
        Ybus[ind_tbus,ind_fbus] += -1/complex(r,x)
        # add diagonal elements of Ybus
        Ybus[ind_fbus,ind_fbus] += 1/complex(r,x)
        Ybus[ind_tbus,ind_tbus] += 1/complex(r,x)
        Ybus[ind_fbus,ind_fbus] += complex(g/2,b/2)
        Ybus[ind_tbus,ind_tbus] += complex(g/2,b/2)
    
    Ybus = sp.csr_matrix(Ybus)
    return Ybus


def red_Ybus(bus,line,tx,mach):
    '''
    Purpose: form the reduced admittance matrix
    
    Input:    bus_sol   - bus solution (generated by loadflow)
              line      - line data
    
    Output:   red_Y     - reduced admittance matrix
              #################################################################
              rec_V     - voltage reconstruction matrix
              Y11,Y12,Y21,Y22 - reduced admittance matrix for
                             systems with non-conforming loads
              rec_V1, rec_V2 - voltage reconstruction bus
              bus_order - vector of bus number for recovering
                           bus voltages
              See also: pst_var, loadflow, ybus
              #################################################################
    
    Calls: full_Ybus
    
    Called By:  
    '''
    
    nbus = len(bus)                     # number of buses
    ngen = len(mach)                    # number of generators
    
    Yd = full_Ybus(bus,line,tx)         # bus admittance matrix construction
    
    # Add load components to the Ybus matrix
    Pl = np.array([bus[i]['pload'] for i in range(nbus)]).reshape(-1,1)
    Ql = np.array([bus[i]['qload'] for i in range(nbus)]).reshape(-1,1)
    Pg = np.array([bus[i]['pgen'] for i in range(nbus)]).reshape(-1,1)
    Qg = np.array([bus[i]['qgen'] for i in range(nbus)]).reshape(-1,1)
    # Get indices for buses with no generator data and treat generation as 
    # negative load
    nogenind = [bus.ind(i) for i in list(set([b['number'] for b in bus])\
                        -set([m['number'] for m in mach]))]
    Pl[nogenind,0] = Pl[nogenind,0] - Pg[nogenind,0]
    Ql[nogenind,0] = Ql[nogenind,0] - Qg[nogenind,0]
    # Form constant impedance load admittance for all buses
    V = np.array([bus[i]['pu'] for i in range(nbus)]).reshape(-1,1)
    yl = ((Pl-1j*Ql)/np.square(V))[:,0]
    ind = range(nbus)
    Yd = Yd + sp.csr_matrix((yl,(ind,ind)))
    
    # Get machine/generator data
    yg = np.array([-1j/m['xd'] for m in mach])
    genind = np.array(range(ngen))
    busind = np.array([bus.ind(mach[j]['number']) for j in range(ngen)])
    P = sp.csr_matrix((np.ones(ngen),(busind,genind)),
                      shape=(nbus,ngen)).toarray()
    
    # Construct the Ybus matrix with generator internal nodes
    # Y_total = [[Ya,Yb],[Yc,Yd]]
    Ya = np.diag(yg)
    Yb = -Ya.dot(P.T)
    Yc = Yb.T
    Yd = Yd.toarray() + P.dot(-Yb)
    
    # Reduced Ybus calculation
    Yred = Ya - np.matmul(Yb,(np.matmul(np.linalg.inv(Yd),Yc)))
    return Yred
    
    

def SlowCoherency(A,n):
    '''
    Identifies the largest n eigen values of the system matrix A and returns
    them along with the corresponding eigen vectors.
    
    Input:  A: System matrix
            n: number of areas (slow coherent areas)
    Output: w: largest n eigen values
            v: corresponding eigenvectors
    '''
    w,v = np.linalg.eig(A)
    idx = w.argsort()[::-1]
    w = w[idx[0:n]]
    v = v[:,idx[0:n]]
    return w,v


def Group(V):
    '''
    '''
    nmach,narea = np.shape(V)
    order = np.array(range(nmach))
    Vaug = np.row_stack((np.zeros(shape=(1,narea+1)),
                         np.column_stack((np.zeros(shape=(nmach,1)),V))))
    # Order the generators to determine the reference buses 
    for i in range(narea):
        Vaug = Vaug[1:nmach-i+1,1:narea-i+1]
        valmax = np.max(abs(Vaug),axis=0)
        rowind = np.argmax(abs(Vaug),axis=0)
        colref = np.argmax(valmax)
        rowref = rowind[colref]
        # Permutations
        order[[i,rowref]] = order[[rowref,i]]
        Vaug[[0,rowref],:] = Vaug[[rowref,0],:]
        Vaug[:,[0,colref]] = Vaug[:,[colref,0]]
        # Gaussian Elimination
        v = (Vaug[:,0]/Vaug[0,0]).reshape(-1,1)
        X = np.matmul(v,Vaug[0,:].reshape(1,-1))
        Vaug = Vaug - X
    
    # Build the modified eigenvector matrix and get area assignment
    Vnew = V[order,:]
    V1 = Vnew[:narea,:]
    V2 = Vnew[narea:,:]
    L = np.matmul(V2,np.linalg.inv(V1))
    k = np.concatenate((np.array(range(narea)),np.argmax(L,axis=1)))
    return order+1,k
        
        
        




















#%% Classes
class iBus(list):
    """
    A class with attributes and methods for a single bus instance.
    The attributes corresponding to each bus instance are as follows:
        0: bus number (integer type)
        1: bus type (integer type, 1: swing bus, 2: generator bus, 3: load bus)
        2: per unit voltage magnitude at the bus (floating type)
        3: bus voltage angle in degrees (floating type)
        4: real power generated or injected at the bus (floating type)
        5: reactive power generated or injected at the bus (floating type)
        6: real power load or consumption at the bus (floating type)
        7: reactive power load or consumption at the bus (floating type)
        8: Minimum reactive power generation at the bus (floating type)
        9: Maximum reactive power generation at the bus (floating type)
        10: Shunt conductance at the bus in MW (floating type)
        11: Shunt susceptance at the bus in MVAR (floating type)
        12: Base voltage of the bus in pu (floating type)
    The attribute values can be accessed using 'list' methods. For example, if
    b is an instance of the class iBus, b[0]=b['number'] will access the
    bus number of the bus.
    """
    def __init__(self,aList):
        '''
        Constructor to initiate a bus instance/object.
        A bus object has two kinds of data. The first data refers a number to
        each variable name (for example bus number, type etc.) and the second 
        data is the input data in the form of list. These two sets of data
        would be used to map the input values to corresponding variable name.
        '''
        super(iBus,self).__init__(aList)
        self.__dict__['d'] = {'number':0, 'type':1, 'pu':2, 'angle':3, 'pgen':4,
                     'qgen':5, 'pload':6, 'qload':7, 'qmin':8, 'qmax':9, 'g':10,
                     'b':11, 'kv':12}
        self.__dict__['data'] = aList
    
    def __getitem__(self,key):
        '''
        A method to get item from class using the key defined in the constructor
        '''
        if isinstance(key,str):
            return self.data[self.d[key.lower()]]
        else:
            return self.data[key]
    
    def __setitem__(self,key,value):
        '''
        A method to get set value for a particular attribute of the instance.
        '''
        if isinstance(key,str):
            self.data[self.d[key.lower()]] = value
        else:
            self.data[key] = value


class iLine(list):
    """
    A class with attributes and methods for a single line instance. The 
    attributes corresponding to each line instance are as follows:
        0: from bus number (integer type)
        1: to bus number (integer type)
        2: line ID (string type)
        3: resistance of line in pu/km (floating type)
        4: reactance of line in pu/km (floating type)
        5: shunt susceptance of line in pu/km (floating type)
        6: status of line (binary type)
        7: length of line in km (floating type)
        8: MVA rating of line (floating type)
        9: kV rating of the line (floating type)
    The attribute values can be accessed using 'list' methods. For example, if
    b is an instance of the class iLine, b[2]=b['id'] will access the
    line ID of the line.
    """
    def __init__(self,aList):
        '''
        Constructor to initiate a line instance/object.
        A line object has two kinds of data. The first data refers a number to
        each variable name (for example from bus, to bus etc.) and the second 
        data is the input data in the form of list. These two sets of data
        would be used to map the input values to corresponding variable name.
        '''
        super(iLine,self).__init__(aList)
        self.__dict__['d'] = {'frombus':0,'tobus':1,'id':2,'r':3,'x':4,'b':5,
                     'st':6, 'length':7, 'mva':8, 'kv':9}
        self.__dict__['data'] = aList
    
    def __getitem__(self,key):
        '''
        A method to get item from class using the key defined in the constructor
        '''
        if isinstance(key,str):
            return self.data[self.d[key.lower()]]
        else:
            return self.data[key]
    
    def __setitem__(self,key,value):
        '''
        A method to get set value for a particular attribute of the instance.
        '''
        if isinstance(key,str):
            self.data[self.d[key.lower()]] = value
        else:
            self.data[key] = value


class iTx(list):
    """
    A class with attributes and methods for a single two winding transformer
    instance. The attributes corresponding to each transformer instance are as 
    follows:
        0: from bus number (integer type)
        1: to bus number (integer type)
        2: transformer ID (string type)
        3: resistance of transformer in pu (floating type)
        4: reactance of transformer in pu (floating type)
        5: shunt conductance of transformer in pu (floating type)
        6: shunt susceptance of transformer in pu (floating type)
        7: tap ratio of transformer (floating type)
        8: status of transformer (binary type)
        9: MVA rating of transformer (floating type)
        10: kV rating of HV side of transformer (floating type)
        11: kV rating of LV side of transformer (floating type)
    The attribute values can be accessed using 'list' methods. For example, if
    b is an instance of the class iTx, b[2]=b['id'] will access the
    transformer ID of the transformer.
    """
    def __init__(self,aList):
        '''
        Constructor to initiate a transformer instance/object.
        A transformer object has two kinds of data. The first data refers a number 
        to each variable name (for example from bus, to bus etc.) and the second 
        data is the input data in the form of list. These two sets of data
        would be used to map the input values to corresponding variable name.
        '''
        super(iTx,self).__init__(aList)
        self.__dict__['d'] = {'frombus':0,'tobus':1,'id':2,'r':3,'x':4,'g':5,
                     'b':6, 'tap':7, 'status':8, 'mva':9, 'hv':10, 'lv':11}
        self.__dict__['data'] = aList
    
    def __getitem__(self,key):
        '''
        A method to get item from class using the key defined in the constructor
        '''
        if isinstance(key,str):
            return self.data[self.d[key.lower()]]
        else:
            return self.data[key]
    
    def __setitem__(self,key,value):
        '''
        A method to get set value for a particular attribute of the instance.
        '''
        if isinstance(key,str):
            self.data[self.d[key.lower()]] = value
        else:
            self.data[key] = value


class iMach(list):
    """
    A class with attributes and methods for a single machine instance.
    The attributes corresponding to each machine instance are as follows:
        0: generator/machine ID (string type)
        1: bus number (integer type)
        2: rating of machine (floating type)
        3: sub-transient reactance (floating type)
        4: machine inertia (floating type)
    The attribute values can be accessed using 'list' methods. For example, if
    g is an instance of the class iMach, g[4]=b['H'] will access the machine
    inertia of the generator.
    """
    def __init__(self,aList):
        '''
        Constructor to initiate a machine or generator instance/object.
        A machine object has two kinds of data. The first data refers a number
        to each variable name (for example bus number, inertia etc.) and the
        second data is the input data in the form of list. These two sets of data
        would be used to map the input values to corresponding variable name.
        '''
        super(iMach,self).__init__(aList)
        self.__dict__['d'] = {'number':0, 'id':1, 'rate':2, 'xd':3, 'h':4,
                     'd':5}
        self.__dict__['data'] = aList
    
    def __getitem__(self,key):
        '''
        A method to get item from class using the key defined in the constructor
        '''
        if isinstance(key,str):
            return self.data[self.d[key.lower()]]
        else:
            return self.data[key]
    
    def __setitem__(self,key,value):
        '''
        A method to get set value for a particular attribute of the instance.
        '''
        if isinstance(key,str):
            self.data[self.d[key.lower()]] = value
        else:
            self.data[key] = value


class Bus(list):
    """
    A class to instantiate all the buses in the system of interest
    """
    def __getitem__(self,key):
        '''
        Returns the bus instance corresponding to key
        '''
        return iBus(self.data[key])
    
    def __iter__(self):
        '''
        Returns as class objects during iterations
        '''
        for p in self.data:
            yield iBus(p)
        
    def __init__(self,*args):
        '''
        '''
        if len(args)==1 and isinstance(args[0],str):
            # Initialize through a csv file
            f = open(args[0],'r')
            cdata = [line.strip('\n').split(',') for line in f.readlines()]
            f.close()
            # Append each line of data one at a time
            self.data = []
            dicref = []
            for k in range(1,len(cdata)):
                L = [int(cdata[k][0]),int(cdata[k][1]),float(cdata[k][2]),
                     float(cdata[k][3]),float(cdata[k][4]),float(cdata[k][5]),
                     float(cdata[k][6]),float(cdata[k][7]),float(cdata[k][8]),
                     float(cdata[k][9]),float(cdata[k][10]),float(cdata[k][11]),
                     float(cdata[k][12])]
                self.__dict__['data'].append(L)
                dicref.append(L[0])
            super(Bus,self).__init__(self.__dict__['data'])
            self.identify = dict(zip(dicref,range(len(cdata))))
        elif len(args) == 1:
            # Initialize through a single list of data
            self.__dict__['data'] = args[0]
            super(Bus,self).__init__(self.__dict__['data'])
            dicref = [col[0] for col in args[0]]
            self.identify = dict(zip(dicref,range(len(args[0]))))
        else:
            # Exception Handling
            print "Wrong number/type of arguments:",str(len(args))
            print "To get data from csv file use: '%pathname%filename.csv'"
            print('To instantiate use a list as the only argument')
    
    def ind(self,number):
        '''
        Identifies the index of the bus in the bus list from the bus number 
        provided as input.
        '''
        ret = []
        key = int(number)
        if self.identify.has_key(key): ret = self.identify[key]
        return ret
    
    def update(self,pfsol):
        '''
        Updates the bus data after a power flow operation.
        '''
        for k in range(len(self.data)):
            if self.data[k][1] == 1:
                self.data[k][4] = pfsol.Pgen[k,0]*base_mva
                self.data[k][5] = pfsol.Qgen[k,0]*base_mva
            elif self.data[k][1] == 2:
                self.data[k][2] = pfsol.V[k,0]
                self.data[k][3] = pfsol.theta[k,0]*(180/np.pi)
                self.data[k][5] = pfsol.Qgen[k,0]*base_mva
            elif self.data[k][1] == 3:
                self.data[k][2] = pfsol.V[k,0]
                self.data[k][3] = pfsol.theta[k,0]*(180/np.pi)
        return



class Line(list):
    """
    A class to instantiate all the lines in the system of interest.
    """
    def __getitem__(self,key):
        '''
        Returns the line instance corresponding to key
        '''
        return iLine(self.data[key])
        
    def __iter__(self):
        '''
        Returns as class objects during iterations
        '''
        for p in self.data:
            yield iLine(p)
            
    def __init__(self,*args):
        '''
        '''
        if len(args)==1 and isinstance(args[0],str):
            # Initialize through a csv file
            f = open(args[0],'r')
            cdata = [line.strip('\n').split(',') for line in f.readlines()]
            f.close()
            # Append each line of data one at a time
            self.data = []
            dicref = []
            for k in range(1,len(cdata)):
                L = [int(cdata[k][0]),int(cdata[k][1]),str(cdata[k][2]).strip(),
                     float(cdata[k][3]),float(cdata[k][4]),float(cdata[k][5]),
                     int(cdata[k][6]),float(cdata[k][7]),float(cdata[k][8]),
                     float(cdata[k][9])]
                self.__dict__['data'].append(L)
                dicref.append((L[0],L[1],L[2]))
            super(Line,self).__init__(self.__dict__['data'])
            self.identify = dict(zip(dicref,range(len(cdata))))
        elif len(args) == 1:
            # Initialize through a single list of data
            self.__dict__['data'] = args[0]
            super(Line,self).__init__(self.__dict__['data'])
            dicref = [(col[0],col[1],col[2].strip()) for col in args[0]]
            self.identify = dict(zip(dicref,range(len(args[0]))))
        else:
            # Exception Handling
            print "Wrong number/type of arguments:",str(len(args))
            print "To get data from csv file use: '%pathname%filename.csv'"
            print('To instantiate use a list as the only argument')
    
    def ind(self,fbus,tbus,bid):
        '''
        Identifies the index of the line in the line list from the from bus,
        to bus and line id provided as input.
        '''
        ret = []
        key = (int(fbus),int(tbus),str(bid).strip())
        if self.identify.has_key(key): ret = self.identify[key]
        return ret
            

class Tx(list):
    """
    A class to instantiate all the two winding transformers in the system of 
    interest.
    """
    def __getitem__(self,key):
        '''
        Returns the transformer instance corresponding to key
        '''
        return iTx(self.data[key])
        
    def __iter__(self):
        '''
        Returns as class objects during iterations
        '''
        for p in self.data:
            yield iTx(p)
            
    def __init__(self,*args):
        '''
        '''
        if len(args)==1 and isinstance(args[0],str):
            # Initialize through a csv file
            f = open(args[0],'r')
            cdata = [line.strip('\n').split(',') for line in f.readlines()]
            f.close()
            # Append each line of data one at a time
            self.data = []
            dicref = []
            for k in range(1,len(cdata)):
                L = [int(cdata[k][0]),int(cdata[k][1]),str(cdata[k][2]).strip(),
                     float(cdata[k][3]),float(cdata[k][4]),float(cdata[k][5]),
                     float(cdata[k][6]),float(cdata[k][7]),int(cdata[k][8]),
                     float(cdata[k][9]),float(cdata[k][10]),float(cdata[k][11])]
                self.__dict__['data'].append(L)
                dicref.append((L[0],L[1],L[2]))
            super(Tx,self).__init__(self.__dict__['data'])
            self.identify = dict(zip(dicref,range(len(cdata))))
        elif len(args) == 1:
            # Initialize through a single list of data
            self.__dict__['data'] = args[0]
            super(Tx,self).__init__(self.__dict__['data'])
            dicref = [(col[0],col[1],col[2].strip()) for col in args[0]]
            self.identify = dict(zip(dicref,range(len(args[0]))))
        else:
            # Exception Handling
            print "Wrong number/type of arguments:",str(len(args))
            print "To get data from csv file use: '%pathname%filename.csv'"
            print('To instantiate use a list as the only argument')
    
    def ind(self,fbus,tbus,bid):
        '''
        Identifies the index of the transformer in the transformer list from 
        the from bus, to bus and transformer id provided as input.
        '''
        ret = []
        key = (int(fbus),int(tbus),str(bid).strip())
        if self.identify.has_key(key): ret = self.identify[key]
        return ret


class Mach(list):
    """
    A class to instantiate all the machines in the system of interest
    """
    def __getitem__(self,key):
        '''
        Returns the bus instance corresponding to key
        '''
        return iMach(self.data[key])
    
    def __iter__(self):
        '''
        Returns as class objects during iterations
        '''
        for p in self.data:
            yield iMach(p)
            
    def __init__(self,*args):
        '''
        '''
        if len(args)==1 and isinstance(args[0],str):
            # Initialize through a csv file
            f = open(args[0],'r')
            cdata = [line.strip('\n').split(',') for line in f.readlines()]
            f.close()
            # Append each line of data one at a time
            self.data = []
            dicref = []
            for k in range(1,len(cdata)):
                L = [int(cdata[k][1]),str(cdata[k][0]),float(cdata[k][2]),
                     float(cdata[k][3]),float(cdata[k][4]),float(cdata[k][5])]
                self.__dict__['data'].append(L)
                dicref.append((L[0],L[1]))
            super(Mach,self).__init__(self.__dict__['data'])
            self.identify = dict(zip(dicref,range(len(cdata))))
        elif len(args) == 1:
            # Initialize through a single list of data
            self.__dict__['data'] = args[0]
            super(Mach,self).__init__(self.__dict__['data'])
            dicref = [(col[0],col[1]) for col in args[0]]
            self.identify = dict(zip(dicref,range(len(args[0]))))
        else:
            # Exception Handling
            print "Wrong number/type of arguments:",str(len(args))
            print "To get data from csv file use: '%pathname%filename.csv'"
            print('To instantiate use a list as the only argument')

    def ind(self,number,gid):
        '''
        Identifies the index of the machine in the machine list from the bus 
        number and generator id provided as input.
        '''
        ret = []
        key = (int(number),str(gid))
        if self.identify.has_key(key): ret = self.identify[key]
        return ret






class PowerFlow:
    """
    A class to perform power flow operation and return the power flow solution 
    as the various attributes of the class instance.
    """
    def __init__(self,bus,line,tx):
        '''
        '''
        self.__pv = np.array([k for k in range(len(bus)) \
                              if bus[k]['type']==2]).reshape(-1,1)
        self.__pq = np.array([k for k in range(len(bus)) \
                              if bus[k]['type']==3]).reshape(-1,1)
        self.__pvpq = np.concatenate((self.__pv,self.__pq))
        self.__nbus = len(bus)
        self.__flatvolt = np.array([1.0 if b['type']==3 else b['pu'] \
                                    for b in bus]).reshape(-1,1)
        
        # Compute Ybus for the power system network
        self.Ybus = full_Ybus(bus,line,tx)
        
        # Calculate the specified real/reactive power injections at all the buses
        # in order of the bus type and initialize the bus voltage array
        self.Qmin = np.array([b['qmin'] for b in bus]).reshape(-1,1)/base_mva
        self.Qmax = np.array([b['qmax'] for b in bus]).reshape(-1,1)/base_mva
        self.Pgen = np.array([b['pgen'] for b in bus]).reshape(-1,1)/base_mva
        self.Qgen = np.array([b['qgen'] for b in bus]).reshape(-1,1)/base_mva
        self.Pload = np.array([b['pload'] for b in bus]).reshape(-1,1)/base_mva
        self.Qload = np.array([b['qload'] for b in bus]).reshape(-1,1)/base_mva
        self.V = np.array([b['pu']for b in bus]).reshape(-1,1)
        self.theta = (np.pi/180)*np.array([b['angle'] for b in bus]).reshape(-1,1)
        
        (self.P,self.Q) = self.__GetPowerInj(self.theta,self.V,self.Ybus)
        self.__ierr = np.max(self.__GetMismatch(self.P,self.Q))
        self.__iter = 0
    
    
    def __GetPowerInj(self,theta,V,Ybus):
        '''
        Evaluates real and reactive power injections at all buses. The power
        injection is the amount of power generated at the bus minus the power
        consumed and is equal to the power flowing out of the bus. That is,
        P_{m,inj}=P_{m,gen}-P_{m,load}=V_{m}\sum_{i=1}^{N}{V_{N}
        (G_{mn}\cos(\theta_{m}-\theta_{n})+B_{mn}\sin(\theta_{m}-\theta_{n}))}
        Q_{m,inj}=Q_{m,gen}-Q_{m,load}=V_{m}\sum_{i=1}^{N}{V_{N}
        (G_{mn}\sin(\theta_{m}-\theta_{n})-B_{mn}\cos(\theta_{m}-\theta_{n}))}
        
        Input:  theta: column vector of voltage angle (in radians) at all buses
                V: column vector of voltage magnitude (in pu) at all buses
                Ybus: Bus admittance matrix of the power system network
        
        Output: (Pcal,Qcal): Tuple of two column vectors: calculated real power
                and calculated reactive power.
        '''
        # Get commonly used matrices
        del_theta = theta - theta.T
        Gcos_Bsin = Ybus.real.multiply(np.cos(del_theta)) \
        + Ybus.imag.multiply(np.sin(del_theta))
        Gsin_Bcos = Ybus.real.multiply(np.sin(del_theta)) \
        - Ybus.imag.multiply(np.cos(del_theta))
        
        # Calculate P and Q injection using power flow equations
        Pcal = V*(Gcos_Bsin.dot(V))
        Qcal = V*(Gsin_Bcos.dot(V))
        return (Pcal,Qcal)
    
    
    def __GetMismatch(self,P,Q):
        '''
        '''
        # Calculate change from specified value
        Psp = self.Pgen - self.Pload
        Qsp = self.Qgen - self.Qload
        dPa = Psp-P
        dQa = Qsp-Q
        
        # Compute the mismatch vector
        dP = dPa[self.__pvpq,0]
        dQ = dQa[self.__pq,0]
        return np.concatenate((dP,dQ))
        
        
        
    def __AdjustQLimit(self,adjust='voltage'):
        '''
        '''
        Qg = self.Q[self.__pv,0] + self.Qload[self.__pv,0]
        if adjust == 'qgen':
            Qg_clip = np.clip(Qg,self.Qmin[self.__pv,0],self.Qmax[self.__pv,0])
            self.Qgen[self.__pv,0] = Qg_clip
            return
        elif adjust == 'voltage':
            check_low = (Qg-self.Qmin[self.__pv,0] >= 0)*1
            check_high = (self.Qmax[self.__pv,0]-Qg >= 0)*1
            adj = 0.01*(check_high - check_low)
            self.V[self.__pv,0] = self.V[self.__pv,0] + adj
            return
    
    
    def __GetPFJacobian(self,theta,V,Ybus):
        '''
        Evaluates the Jacobian at the given operating point. Computes the four
        partitions separately and concatenates the submatrices to form the
        Jacobian matrix.
        
        Input:  theta: numpy column vector/array of bus voltage angles
                V: numpy column vector/array of bus voltage magnitudes in pu
                Ybus: Ybus matrix as a CSR sparse matrix
                Note that theta and V indicate the operating point and Ybus 
                denotes the operating topology of the network.
        
        Output: The power flow Jacobian matrix computed at the operating point
        '''
        # Get commonly used matrices
        del_theta = theta - theta.T
        Gcos_Bsin = Ybus.real.multiply(np.cos(del_theta)) \
        + Ybus.imag.multiply(np.sin(del_theta))
        Gsin_Bcos = Ybus.real.multiply(np.sin(del_theta)) \
        - Ybus.imag.multiply(np.cos(del_theta))
        
        # Calculation of 4 partitions of Jacobian
        # J1 - Derivative of Real Power Injections with Angles..
        J1a = Gsin_Bcos.multiply(V.dot(V.T))
        J1b = -np.diag((V*(Gsin_Bcos.dot(V)))[:,0])
        J1 = (J1a+J1b)[self.__pvpq,self.__pvpq.T]
        # J2 - Derivative of Real Power Injections with V..
        J2a = Gcos_Bsin.multiply((V*np.ones(self.__nbus)))
        J2b = np.diag((Gcos_Bsin.dot(V))[:,0])
        J2 = (J2a+J2b)[self.__pvpq,self.__pq.T]
        # J3 - Derivative of Reactive Power Injections with Angles..
        J3a = -Gcos_Bsin.multiply(V.dot(V.T))
        J3b = np.diag((V*(Gcos_Bsin.dot(V)))[:,0])
        J3 = (J3a+J3b)[self.__pq,self.__pvpq.T]
        # J4 - Derivative of Reactive Power Injections with V..
        J4a = Gsin_Bcos.multiply(V*np.ones(self.__nbus))
        J4b = np.diag((Gsin_Bcos.dot(V))[:,0])
        J4 = (J4a+J4b)[self.__pq,self.__pq.T]
        
        J = np.concatenate((np.concatenate((J1,J2),axis=1),\
                            np.concatenate((J3,J4),axis=1)),axis=0)
        
        return J
    
    
    def ACPF(self,flat_start=False,tol=1e-6,max_iter=100):
        '''
        Run AC power flow to evaluate the power system states. The states are 
        bus voltage magnitudes and bus voltage angles.
        
        Optional arguments:
        flat_start: binary variable to toggle flat start (default is True)
        tol: allowable error tolerance (default is 1e-6)
        max_iter: Maximum number of allowable iterations before stopping
        (default is 100)
        '''
        # If flat start, update the voltage and angles accordingly
        if flat_start:
            self.__ierr = 1
            self.V = self.__flatvolt
            self.theta = 0.0 * self.theta
        
        # Start the Newton Raphson power flow iterations
        while(self.__ierr > tol):
            # If number of iterations exceed maximum allowable iterations
            if self.__iter == max_iter:
                print "POWER FLOW SOLUTION DID NOT CONVERGE IN",self.__iter,\
                "ITERATIONS"
                break
            self.__iter +=1
            
            # Evaluate jacobian matrix and power injections
            J = self.__GetPFJacobian(self.theta,self.V,self.Ybus)
            (self.P,self.Q) = self.__GetPowerInj(self.theta,self.V,self.Ybus)
            # Check Q-limit violation and adjust accordingly
            self.__AdjustQLimit()
            # Compute the mismatch vector
            M = self.__GetMismatch(self.P,self.Q)
            # Evaluate change in state vectors
            X = np.matmul(np.linalg.inv(J),M)
            
            # Update state vectors
            self.theta[self.__pvpq,0] = X[:len(self.__pvpq)]+self.theta[self.__pvpq,0]
            self.V[self.__pq,0] = X[len(self.__pvpq):] + self.V[self.__pq,0]
            
            self.__ierr = np.max(M)
        
        # Outside the power flow iteration loop
        if self.__iter < max_iter:
            print "Power flow solution obtained after",self.__iter,"iterations",\
            "with a power injection mismatch of %8f"%(self.__ierr),"pu."
            self.Pgen = self.P+self.Pload
            self.Qgen = self.Q+self.Qload
        return
    


class SmallSignal:
    """
    """
    def __init__(self,bus,line,tx,mach,pfsol):
        '''
        '''
        gen = np.array(range(len(bus),len(bus)+len(mach))).reshape(-1,1)
        nongen = np.array(range(len(bus))).reshape(-1,1)
        YbusDC = self.__GetYbusDC(bus,line,tx,mach)
        self.Ybusred = KronRed(YbusDC,gen,nongen)
        (self.E,self.delta) = self.__IntVoltage(bus,mach,pfsol)
        self.Asys = np.zeros(shape=(2*len(mach),2*len(mach)),dtype=float)
        return
        
        
    def __IntVoltage(self,bus,mach,pfsol):
        '''
        Evaluates the generator bus internal voltage magnitudes and angles.
        '''
        gbus = np.array([bus.ind(m['number']) for m in mach]).reshape(-1,1)
        cos_theta = np.cos(pfsol.theta[gbus,0])
        sin_theta = np.sin(pfsol.theta[gbus,0])
        Sgen = pfsol.Pgen[gbus,0] + 1j*pfsol.Qgen[gbus,0]
        V = pfsol.V[gbus,0]*(cos_theta+1j*sin_theta)
        I = (Sgen/V).conjugate()
        X = np.array([m['xd'] for m in mach]).reshape(-1,1)*(1j)
        E = V + (I*X)
        
        Emag = abs(E); Eang = np.arctan2(E.imag,E.real)
        return (Emag,Eang)
    
    
    def __GetYbusDC(self,bus,line,tx,mach):
        '''
        Evaluates the Ybus matrix under DC approximation for a given power 
        system network. Ignores the resistances and shunt admittances.
        '''
        Ybus = np.zeros(shape=(len(bus)+len(mach),len(bus)+len(mach)),\
                        dtype=complex)
        # Line reactances
        for k in range(len(line)):
            # find index of buses
            ind_fbus = bus.ind(line[k]['frombus'])
            ind_tbus = bus.ind(line[k]['tobus'])
            # evaluate reactance
            x = line[k]['x']*line[k]['length']*base_mva/line[k]['mva']
            # add off-diagonal elements of Ybus
            Ybus[ind_fbus,ind_tbus] += -1/x
            Ybus[ind_tbus,ind_fbus] += -1/x
        # Transformer reactances
        for k in range(len(tx)):
            # find index of buses
            ind_fbus = bus.ind(tx[k]['frombus'])
            ind_tbus = bus.ind(tx[k]['tobus'])
            # evaluate reactance
            x = tx[k]['x']*base_mva/tx[k]['mva']
            # add off-diagonal elements of Ybus
            Ybus[ind_fbus,ind_tbus] += -1/x
            Ybus[ind_tbus,ind_fbus] += -1/x
        for m in range(len(mach)):
            # find index of machine bus
            ind_mbus = bus.ind(mach[m]['number'])
            x = mach[m]['xd']*base_mva/mach[m]['rate']
            Ybus[ind_mbus,len(bus)+m] = -1/x
            Ybus[len(bus)+m,ind_mbus] = -1/x
        
        for n in range(len(bus)+len(mach)):
            Ybus[n,n] = -np.sum(Ybus[n,:])
        
        return Ybus
    
    
    def BuildStateMatrix(self,mach):
        '''
        '''
        ngen = len(mach)
        Ks = (self.E.dot(self.E.T))*np.cos(self.delta-self.delta.T)*self.Ybusred
        #Ks = self.Ybusred
        Kd = np.identity(ngen)*10
        Minv = np.diag([1/((2*m['h'])*(m['rate']/base_mva)) for m in mach])
        
        A1 = np.zeros(shape=(ngen,ngen))
        A2 = omega*np.identity(ngen)
        A3 = -Minv.dot(Ks)
        A4 = -Minv.dot(Kd)
        
        self.Asys = np.concatenate((np.concatenate((A1,A2),axis=1),\
                                    np.concatenate((A3,A4),axis=1)),axis=0)
        return
    
    

class Machine:
    """
    Generates dynamic models for a electromechanical machine model with the 
    following paramters.
    """
    def __init__(self,mach,bus):
        '''
        '''
        # Machine data/parameters
        self.__ngen = len(mach)
        self.busind = [mach.ind(mach[i]['number'],mach[i]['id']) \
                       for i in range(self.__ngen)]
        self.scale = np.array([base_mva/mach[i]['rate'] \
                                    for i in range(len(mach))]).reshape(-1,1)
        self.xd = np.array([mach[i]['xd'] \
                            for i in range(self.__ngen)]).reshape(-1,1)
        self.D = np.array([mach[i]['d'] \
                           for i in range(self.__ngen)]).reshape(-1,1)
        self.H = np.array([mach[i]['h'] \
                           for i in range(self.__ngen)]).reshape(-1,1)
        
        # Get data from solved power flow
        Vmag = np.array([bus[i]['pu'] for i in self.busind]).reshape(-1,1)
        theta = np.array([bus[i]['angle'] \
                          for i in self.busind]).reshape(-1,1)*np.pi/180
        V = Vmag*np.exp(1j*(theta))
        # Real/Reactive power on system MVA base
        self.P = np.array([bus[i]['pgen'] \
                               for i in self.busind]).reshape(-1,1)/base_mva
        self.Q = np.array([bus[i]['qgen'] \
                               for i in self.busind]).reshape(-1,1)/base_mva
        
        # Mechanical power on generator mva base
        self.Pmech = self.P*self.scale
        
        # Generator current on generator MVA base
        I = self.scale*((self.P+1j*self.Q).conjugate()/V)
       
        # Computing stator variables
        self.psi = V + 1j*self.xd*I
        
        # Computing stator variables in rotating frame of reference
        self.delta = np.angle(self.psi)
        self.speed = np.ones(shape=(self.__ngen,1))
        rot = 1j*np.exp(-1j*self.delta)
        Erot = self.psi*rot; Irot = I*rot; Vrot = V*rot
        self.Ed = Erot.real; self.Eq = Erot.imag
        self.Vd = Vrot.real; self.Vq = Vrot.imag
        self.Idg = Irot.real; self.Iqg = Irot.imag
        self.Vex = self.Eq
        
        # Generator currents on system mva base
        self.Id = self.Idg/self.scale
        self.Iq = self.Iqg/self.scale
        
        # Initialize delta variables
        self.d_delta = np.zeros(shape=(self.__ngen,1))
        self.d_speed = np.zeros(shape=(self.__ngen,1))
        self.A = np.zeros(shape=(2*self.__ngen,2*self.__ngen))
        return
    
    
    def GenDyn(self,ref,Yred):
        '''
        '''
        self.d_delta = np.zeros(shape=(self.__ngen,1))
        self.d_speed = np.zeros(shape=(self.__ngen,1))
        
        self.delta = self.delta - ref
        self.psi = (np.sin(self.delta)*self.Ed \
                    + np.cos(self.delta)*self.Eq) \
                    + 1j*(-np.cos(self.delta)*self.Ed \
                          + np.sin(self.delta)*self.Eq)
        
        # Calculation on system base
        I = Yred.dot(self.psi)
        self.Id = I.real*np.sin(self.delta) - I.imag*np.cos(self.delta)
        self.Iq = I.real*np.cos(self.delta) + I.imag*np.sin(self.delta)
        
        # Calculation on generator mva base
        self.Idg = self.Id*self.scale; self.Iqg = self.Iq*self.scale
        self.Vd = self.Ed + (self.xd*self.Iqg)
        self.Vq = self.Eq - (self.xd*self.Idg)
        
        # Calculation of real/reactive power on system base
        self.P = self.Eq*self.Iq + self.Ed*self.Id
        self.Q = self.Eq*self.Id - self.Ed*self.Iq
        
        self.d_delta = omega*(self.speed-np.ones(shape=(self.__ngen,1)))
        self.d_speed = (self.Pmech-(self.P*self.scale)-\
                        (self.D*(self.speed-np.ones(shape=(self.__ngen,1)))))\
                        /(2*self.H)
        return
    
    
    def Perturb(self,Yred,perturb = 1e-3,ref=0):
        '''
        '''
        for i in range(self.__ngen):
            pert = np.zeros(shape=(self.__ngen,1))
            nominal = self.delta
            pert[i,0] = perturb * self.delta[i,0]
            self.delta = nominal + pert
            self.GenDyn(ref,Yred)
            self.A[:self.__ngen,i] = self.d_delta[:,0]/pert[i,0]
            self.A[self.__ngen:,i] = self.d_speed[:,0]/pert[i,0]
            self.delta = nominal
        for i in range(self.__ngen):
            pert = np.zeros(shape=(self.__ngen,1))
            nominal = self.speed
            pert[i,0] = perturb * self.speed[i,0]
            self.speed = nominal + pert
            self.GenDyn(ref,Yred)
            self.A[:self.__ngen,i+self.__ngen] = self.d_delta[:,0]/pert[i,0]
            self.A[self.__ngen:,i+self.__ngen] = self.d_speed[:,0]/pert[i,0]
            self.speed = nominal
        return self.A[self.__ngen:,:self.__ngen]






















