# -*- coding: utf-8 -*-
"""
Created on Mon Dec 14 23:06:09 2020

@author: rouna
"""

import numpy as np
import scipy.sparse as sp
import matplotlib.pyplot as plt

global base_mva, base_kV, omega, Zbase
base_mva = 100.0
base_kV = 33.0
omega = 2*np.pi*60
Zbase = (base_kV**2)/base_mva

def full_Ybus(bus,line,tx):
    '''
    Evaluates the Ybus matrix for a given power system network.
    #######################################################################
    REQUIRES UPDATE USING EFFICIENT CSR MATRIX ALGORITHM
    CURRENTLY JUST CONVERTS NUMPY 2D ARRAY TO A CSR MATRIX.
    NEED TO FILL THE ENTIRE MATRIX AS A CSR MATRIX (COMPUTATIONALLY AND
    MEMORYWISE EFFICIENT)
    #######################################################################
    '''
    
    Ybus = np.zeros(shape=(len(bus),len(bus)),dtype=complex)
    # Shunt admittances of each bus
    for m in range(len(bus)):
        g = bus[m]['g']/base_mva
        b = bus[m]['b']/base_mva
        Ybus[m,m] += complex(g,b)
    # Line impedances and admittances
    for k in range(len(line)):
        # find index of buses
        ind_fbus = bus.ind(line[k]['frombus'])
        ind_tbus = bus.ind(line[k]['tobus'])
        # evaluate resistance, reactance and susceptance
        if line[k]['length']==0.0:
            length = 1.0
        else:
            length = line[k]['length']
        r = line[k]['r']*length*base_mva/line[k]['mva']
        x = line[k]['x']*length*base_mva/line[k]['mva']
        b = line[k]['b']*length*line[k]['mva']/base_mva
        # add off-diagonal elements of Ybus
        Ybus[ind_fbus,ind_tbus] += -1/complex(r,x)
        Ybus[ind_tbus,ind_fbus] += -1/complex(r,x)
        # add diagonal elements of Ybus
        Ybus[ind_fbus,ind_fbus] += 1/complex(r,x)
        Ybus[ind_tbus,ind_tbus] += 1/complex(r,x)
        Ybus[ind_fbus,ind_fbus] += complex(0,b/2)
        Ybus[ind_tbus,ind_tbus] += complex(0,b/2)
    # Transformer impedances and admittances
    #######################################################################
    #Requires checking of pu calculation for transfomrer voltage
    #How to calculate pu impedance for transformer for any base 
    #######################################################################
    for t in range(len(tx)):
        # find index of buses
        ind_fbus = bus.ind(tx[t]['frombus'])
        ind_tbus = bus.ind(tx[t]['tobus'])
        # evaluate resistance, reactance and susceptance
        r = tx[t]['r']*base_mva/tx[t]['mva']
        x = tx[t]['x']*base_mva/tx[t]['mva']
        g = tx[t]['g']*tx[t]['mva']/base_mva
        b = tx[t]['b']*tx[t]['mva']/base_mva
        # add off-diagonal elements of Ybus
        Ybus[ind_fbus,ind_tbus] += -1/complex(r,x)
        Ybus[ind_tbus,ind_fbus] += -1/complex(r,x)
        # add diagonal elements of Ybus
        Ybus[ind_fbus,ind_fbus] += 1/complex(r,x)
        Ybus[ind_tbus,ind_tbus] += 1/complex(r,x)
        Ybus[ind_fbus,ind_fbus] += complex(g/2,b/2)
        Ybus[ind_tbus,ind_tbus] += complex(g/2,b/2)
    
    Ybus = sp.csr_matrix(Ybus)
    return Ybus

def red_Ybus(bus,line,tx,mach):
    '''
    Purpose: form the reduced admittance matrix
    
    Input:    bus_sol   - bus solution (generated by loadflow)
              line      - line data
    
    Output:   red_Y     - reduced admittance matrix
              #################################################################
              rec_V     - voltage reconstruction matrix
              Y11,Y12,Y21,Y22 - reduced admittance matrix for
                             systems with non-conforming loads
              rec_V1, rec_V2 - voltage reconstruction bus
              bus_order - vector of bus number for recovering
                           bus voltages
              See also: pst_var, loadflow, ybus
              #################################################################
    
    Calls: full_Ybus
    
    Called By:  
    '''
    
    nbus = len(bus)                     # number of buses
    ngen = len(mach)                    # number of generators
    
    Yd = full_Ybus(bus,line,tx)         # bus admittance matrix construction
    
    # Add load components to the Ybus matrix
    Pl = np.array([bus[i]['pload'] for i in range(nbus)]).reshape(-1,1)
    Ql = np.array([bus[i]['qload'] for i in range(nbus)]).reshape(-1,1)
    Pg = np.array([bus[i]['pgen'] for i in range(nbus)]).reshape(-1,1)
    Qg = np.array([bus[i]['qgen'] for i in range(nbus)]).reshape(-1,1)
    # Get indices for buses with no generator data and treat generation as 
    # negative load
    nogenind = [bus.ind(i) for i in list(set([b['number'] for b in bus])\
                        -set([m['number'] for m in mach]))]
    Pl[nogenind,0] = Pl[nogenind,0] - Pg[nogenind,0]
    Ql[nogenind,0] = Ql[nogenind,0] - Qg[nogenind,0]
    # Form constant impedance load admittance for all buses
    V = np.array([bus[i]['pu'] for i in range(nbus)]).reshape(-1,1)
    yl = ((Pl-1j*Ql)/np.square(V))[:,0]
    ind = range(nbus)
    Yd = Yd + sp.csr_matrix((yl,(ind,ind)))
    
    # Get machine/generator data
    yg = np.array([-1j/m['xd'] for m in mach])
    genind = np.array(range(ngen))
    busind = np.array([bus.ind(mach[j]['number']) for j in range(ngen)])
    P = sp.csr_matrix((np.ones(ngen),(busind,genind)),
                      shape=(nbus,ngen)).toarray()
    
    # Construct the Ybus matrix with generator internal nodes
    # Y_total = [[Ya,Yb],[Yc,Yd]]
    Ya = np.diag(yg)
    Yb = -Ya.dot(P.T)
    Yc = Yb.T
    Yd = Yd.toarray() + P.dot(-Yb)
    
    # Reduced Ybus calculation
    Yred = Ya - np.matmul(Yb,(np.matmul(np.linalg.inv(Yd),Yc)))
    return Yred


class PowerFlow:
    """
    A class to perform power flow operation and return the power flow solution 
    as the various attributes of the class instance.
    """
    def __init__(self,bus,line,tx):
        '''
        '''
        self.__pv = np.array([k for k in range(len(bus)) \
                              if bus[k]['type']==2]).reshape(-1,1)
        self.__pq = np.array([k for k in range(len(bus)) \
                              if bus[k]['type']==3]).reshape(-1,1)
        self.__pvpq = np.concatenate((self.__pv,self.__pq))
        self.__nbus = len(bus)
        self.__flatvolt = np.array([1.0 if b['type']==3 else b['pu'] \
                                    for b in bus]).reshape(-1,1)
        
        # Compute Ybus for the power system network
        self.Ybus = full_Ybus(bus,line,tx)
        
        # Calculate the specified real/reactive power injections at all the buses
        # in order of the bus type and initialize the bus voltage array
        self.Qmin = np.array([b['qmin'] for b in bus]).reshape(-1,1)/base_mva
        self.Qmax = np.array([b['qmax'] for b in bus]).reshape(-1,1)/base_mva
        self.Pgen = np.array([b['pgen'] for b in bus]).reshape(-1,1)/base_mva
        self.Qgen = np.array([b['qgen'] for b in bus]).reshape(-1,1)/base_mva
        self.Pload = np.array([b['pload'] for b in bus]).reshape(-1,1)/base_mva
        self.Qload = np.array([b['qload'] for b in bus]).reshape(-1,1)/base_mva
        self.V = np.array([b['pu']for b in bus]).reshape(-1,1)
        self.theta = (np.pi/180)*np.array([b['angle'] for b in bus]).reshape(-1,1)
        
        (self.P,self.Q) = self.__GetPowerInj(self.theta,self.V,self.Ybus)
        M = self.__GetMismatch(self.P,self.Q)
        self.__ierr = np.max(M)
        self.__iter = 0
        
        # Initialize array for voltage magnitudes and angles over iterations
        self.V_iter = self.V
        self.theta_iter = self.theta
        self.mismatch_iter = M.reshape(-1,1)
        return
    
    
    def __GetPowerInj(self,theta,V,Ybus):
        '''
        Evaluates real and reactive power injections at all buses. The power
        injection is the amount of power generated at the bus minus the power
        consumed and is equal to the power flowing out of the bus. That is,
        P_{m,inj}=P_{m,gen}-P_{m,load}=V_{m}\sum_{i=1}^{N}{V_{N}
        (G_{mn}\cos(\theta_{m}-\theta_{n})+B_{mn}\sin(\theta_{m}-\theta_{n}))}
        Q_{m,inj}=Q_{m,gen}-Q_{m,load}=V_{m}\sum_{i=1}^{N}{V_{N}
        (G_{mn}\sin(\theta_{m}-\theta_{n})-B_{mn}\cos(\theta_{m}-\theta_{n}))}
        
        Input:  theta: column vector of voltage angle (in radians) at all buses
                V: column vector of voltage magnitude (in pu) at all buses
                Ybus: Bus admittance matrix of the power system network
        
        Output: (Pcal,Qcal): Tuple of two column vectors: calculated real power
                and calculated reactive power.
        '''
        # Get commonly used matrices
        del_theta = theta - theta.T
        Gcos_Bsin = Ybus.real.multiply(np.cos(del_theta)) \
        + Ybus.imag.multiply(np.sin(del_theta))
        Gsin_Bcos = Ybus.real.multiply(np.sin(del_theta)) \
        - Ybus.imag.multiply(np.cos(del_theta))
        
        # Calculate P and Q injection using power flow equations
        Pcal = V*(Gcos_Bsin.dot(V))
        Qcal = V*(Gsin_Bcos.dot(V))
        return (Pcal,Qcal)
    
    
    def __GetMismatch(self,P,Q):
        '''
        '''
        # Calculate change from specified value
        Psp = self.Pgen - self.Pload
        Qsp = self.Qgen - self.Qload
        dPa = Psp-P
        dQa = Qsp-Q
        
        # Compute the mismatch vector
        dP = dPa[self.__pvpq,0]
        dQ = dQa[self.__pq,0]
        return np.concatenate((dP,dQ))
        
        
        
    def __AdjustQLimit(self,adjust='voltage'):
        '''
        '''
        Qg = self.Q[self.__pv,0] + self.Qload[self.__pv,0]
        if adjust == 'qgen':
            Qg_clip = np.clip(Qg,self.Qmin[self.__pv,0],self.Qmax[self.__pv,0])
            self.Qgen[self.__pv,0] = Qg_clip
            return
        elif adjust == 'voltage':
            check_low = (Qg-self.Qmin[self.__pv,0] >= 0)*1
            check_high = (self.Qmax[self.__pv,0]-Qg >= 0)*1
            adj = 0.01*(check_high - check_low)
            self.V[self.__pv,0] = self.V[self.__pv,0] + adj
            return
    
    
    def __GetPFJacobian(self,theta,V,Ybus):
        '''
        Evaluates the Jacobian at the given operating point. Computes the four
        partitions separately and concatenates the submatrices to form the
        Jacobian matrix.
        
        Input:  theta: numpy column vector/array of bus voltage angles
                V: numpy column vector/array of bus voltage magnitudes in pu
                Ybus: Ybus matrix as a CSR sparse matrix
                Note that theta and V indicate the operating point and Ybus 
                denotes the operating topology of the network.
        
        Output: The power flow Jacobian matrix computed at the operating point
        '''
        # Get commonly used matrices
        del_theta = theta - theta.T
        Gcos_Bsin = Ybus.real.multiply(np.cos(del_theta)) \
        + Ybus.imag.multiply(np.sin(del_theta))
        Gsin_Bcos = Ybus.real.multiply(np.sin(del_theta)) \
        - Ybus.imag.multiply(np.cos(del_theta))
        
        # Calculation of 4 partitions of Jacobian
        # J1 - Derivative of Real Power Injections with Angles..
        J1a = Gsin_Bcos.multiply(V.dot(V.T))
        J1b = -np.diag((V*(Gsin_Bcos.dot(V)))[:,0])
        J1 = (J1a+J1b)[self.__pvpq,self.__pvpq.T]
        # J2 - Derivative of Real Power Injections with V..
        J2a = Gcos_Bsin.multiply((V*np.ones(self.__nbus)))
        J2b = np.diag((Gcos_Bsin.dot(V))[:,0])
        J2 = (J2a+J2b)[self.__pvpq,self.__pq.T]
        # J3 - Derivative of Reactive Power Injections with Angles..
        J3a = -Gcos_Bsin.multiply(V.dot(V.T))
        J3b = np.diag((V*(Gcos_Bsin.dot(V)))[:,0])
        J3 = (J3a+J3b)[self.__pq,self.__pvpq.T]
        # J4 - Derivative of Reactive Power Injections with V..
        J4a = Gsin_Bcos.multiply(V*np.ones(self.__nbus))
        J4b = np.diag((Gsin_Bcos.dot(V))[:,0])
        J4 = (J4a+J4b)[self.__pq,self.__pq.T]
        
        J = np.concatenate((np.concatenate((J1,J2),axis=1),\
                            np.concatenate((J3,J4),axis=1)),axis=0)
        
        return J
    
    
    def ACPF(self,flat_start=False,tol=1e-6,max_iter=100):
        '''
        Run AC power flow to evaluate the power system states. The states are 
        bus voltage magnitudes and bus voltage angles.
        
        Optional arguments:
        flat_start: binary variable to toggle flat start (default is True)
        tol: allowable error tolerance (default is 1e-6)
        max_iter: Maximum number of allowable iterations before stopping
        (default is 100)
        '''
        # If flat start, update the voltage and angles accordingly
        if flat_start:
            self.__ierr = 1
            self.V = self.__flatvolt
            self.V_iter = self.__flatvolt
            self.theta = 0.0 * self.theta
            self.theta_iter = self.theta
        
        # Start the Newton Raphson power flow iterations
        while(self.__ierr > tol):
            # If number of iterations exceed maximum allowable iterations
            if self.__iter == max_iter:
                print("POWER FLOW SOLUTION DID NOT CONVERGE IN",self.__iter,\
                "ITERATIONS")
                break
            self.__iter +=1
            
            # Evaluate jacobian matrix and power injections
            J = self.__GetPFJacobian(self.theta,self.V,self.Ybus)
            (self.P,self.Q) = self.__GetPowerInj(self.theta,self.V,self.Ybus)
            # Check Q-limit violation and adjust accordingly
            self.__AdjustQLimit()
            # Compute the mismatch vector
            M = self.__GetMismatch(self.P,self.Q)
            # Evaluate change in state vectors
            X = np.matmul(np.linalg.inv(J),M)
            
            # Update state vectors
            self.theta[self.__pvpq,0] = X[:len(self.__pvpq)]+self.theta[self.__pvpq,0]
            self.V[self.__pq,0] = X[len(self.__pvpq):] + self.V[self.__pq,0]
            
            self.__ierr = np.max(M)
            self.V_iter = np.hstack((self.V_iter,self.V))
            self.theta_iter = np.hstack((self.theta_iter,self.theta))
            self.mismatch_iter = np.hstack((self.mismatch_iter,M.reshape(-1,1)))
        
        # Outside the power flow iteration loop
        if self.__iter < max_iter:
            print("Power flow solution obtained after",self.__iter,"iterations",\
            "with a power injection mismatch of %8f"%(self.__ierr),"pu.")
            self.Pgen = self.P+self.Pload
            self.Qgen = self.Q+self.Qload
        return